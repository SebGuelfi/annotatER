
#' @param intergenicRegions the intergenic regions generated by DERFINDER
#' @param coverageIntergenic
#' @param annotatedJunction a data.frame with the data generated

annotatERJunction <- function(regions,annotatedJunction)
{
    ##############################################################################
    ## this is the stage 1. annotation is done using the annotated split reads ###
    ##############################################################################
    library(data.table)
    library(tidyverse)
    if(!all(is.element("acceptor",colnames(annotatedJunction)),
           is.element("donor",colnames(annotatedJunction)),
           is.element("junction",colnames(annotatedJunction))))
    {
        stop("The annotatedJunction table do not contain either the acceptor or
             donor or junction column name/s")
    }

    message(paste(Sys.time(),"Annotating regions with partially annotated split reads"))
    ## first step is remove those junctions that are annotated from both ends. These are not adding any information and remove the unannotated junctions
    tmp.annotatedJunction <-  annotatedJunction[which((annotatedJunction$acceptor!="" | annotatedJunction$donor!="") & annotatedJunction$junction==""),]

    ## +- 1 in the coordinates to match the exon boundaries
    if(grepl("chr",as.character(annotatedJunction$chr[1])))
    {
        juncti.GR <- GRanges(c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr)),
                             IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
                                     end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
                             junID=c(tmp.annotatedJunction$junID,tmp.annotatedJunction$junID))

    }else{
        juncti.GR <- GRanges(paste0("chr",c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr))),
                             IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
                                     end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
                             junID=c(tmp.annotatedJunction$junID,tmp.annotatedJunction$junID))
    }

    regionJuncOve <- findOverlaps(regions,juncti.GR,ignore.strand=FALSE)

    tmp.regions <- as.data.frame(regions,row.names = NULL)
    tmp.regions[ ,c(colnames(tmp.annotatedJunction)[c(1,6:11)],"pred_strand","multi_junc","junER","distance","transcript","annotationType")] <- NA


    ## adding the information on the junction id, selecting the junction id with maximum number of samples, if the region overlap with multiple junctions
    regionJuncOve.df <- as.data.frame(regionJuncOve)
    regionJuncOve.df <- cbind(regionJuncOve.df,countsSamples=tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"],tmp.annotatedJunction$junID),"countsSamples"])
    regionJuncOve.df <- as.data.frame(regionJuncOve.df %>% group_by(queryHits) %>% dplyr::slice(which.max(countsSamples)))
    tmp.regions[regionJuncOve.df$queryHits,c(colnames( tmp.annotatedJunction)[c(1,6:11)],"pred_strand")] <- tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"],tmp.annotatedJunction$junID),c(colnames( tmp.annotatedJunction)[c(1,6:11)],"strand")]

    message(paste(Sys.time(),"Adding information of possible multiple split reads annotating the regions"))
    ## adding the information in case regions have multiple id junctions overlappiong
    regionJuncOve.df <- as.data.frame(regionJuncOve)
    regionJuncOve.df <- cbind(regionJuncOve.df,junID=mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"])
    regionJuncOve.df <- regionJuncOve.df %>% group_by(queryHits) %>% summarise(multiple_junc = paste(unique(junID), collapse=","))
    tmp.regions[regionJuncOve.df$queryHits,"multi_junc"] <- regionJuncOve.df$multiple_junc
    tmp.regions[regionJuncOve.df$queryHits,"annotationType"] <- 1

    message(paste(Sys.time(),"Adding split read distance"))
    tmp.regions[!is.na(tmp.regions$junID),"distance"] <- apply(abs(cbind(tmp.regions[!is.na(tmp.regions$junID),"start"] -
                                                                                                 annotatedJunction[match(tmp.regions[!is.na(tmp.regions$junID),"junID"],annotatedJunction$junID),"stop"],
                                                                                             tmp.regions[!is.na(tmp.regions$junID),"end"] -
                                                                                                 annotatedJunction[match(tmp.regions[!is.na(tmp.regions$junID),"junID"],annotatedJunction$junID),"stop"],
                                                                                             tmp.regions[!is.na(tmp.regions$junID),"start"] -
                                                                                                 annotatedJunction[match(tmp.regions[!is.na(tmp.regions$junID),"junID"],annotatedJunction$junID),"start"],
                                                                                             tmp.regions[!is.na(tmp.regions$junID),"end"] -
                                                                                                 annotatedJunction[match(tmp.regions[!is.na(tmp.regions$junID),"junID"],annotatedJunction$junID),"start"])),1,max)


    # add the transcript information
    regionJuncOve.df <- as.data.frame(regionJuncOve)
    regionJuncOve.df <- cbind(regionJuncOve.df,tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"],
                                                                           tmp.annotatedJunction$junID),c("acceptor","donor")])
    regionJuncOve.df <- regionJuncOve.df %>% group_by(queryHits) %>% summarise(transcript = paste(unique(unlist(strsplit(as.character(c(acceptor,donor)),","))), collapse=","))

    tmp.regions[regionJuncOve.df$queryHits,"transcript"] <- regionJuncOve.df$transcript


    ## make the data frame consistent
    tmp.regions[tmp.regions==""] <- NA

    #########################################################
    ## step 2. annotate using non-annotated split reads   ###
    #########################################################


    library(stringr)

    message(paste(Sys.time(),"Annotating regions with unannotated split reads"))
    tmp.annotatedJunction <-  annotatedJunction[which(annotatedJunction$acceptor=="" | annotatedJunction$donor=="" | annotatedJunction$junction==""),]


    if(grepl("chr",as.character(annotatedJunction$chr[1])))
    {
        juncti.GR <- GRanges(c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr)),
                             IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
                                     end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
                             junID=c(tmp.annotatedJunction$junID,tmp.annotatedJunction$junID))

    }else{
        juncti.GR <- GRanges(paste0("chr",c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr))),
                             IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
                                     end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
                             junID=c(tmp.annotatedJunction$junID,tmp.annotatedJunction$junID))
    }

    regionJuncOve <- findOverlaps(regions,juncti.GR,ignore.strand=FALSE)

    ## adding the information on the junction id, selecting the junction id with maximum number of samples, if the region overlap with multiple junctions
    regionJuncOve.df <- as.data.frame(regionJuncOve)
    regionJuncOve.df <- cbind(regionJuncOve.df,junID=mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"])
    ## I remove those indexes that are already annotated
    regionJuncOve.df <- regionJuncOve.df[!regionJuncOve.df$queryHits%in%which(!is.na(tmp.regions$junID)),]

    regionJuncOve.df <- cbind(regionJuncOve.df,countsSamples=tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"junID"],tmp.annotatedJunction$junID),"countsSamples"])
    regionJuncOve.df <- as.data.frame(regionJuncOve.df %>% group_by(queryHits) %>% dplyr::slice(which.max(countsSamples)))

    ## link regions using the split reads
    # regionJuncOve.df <- as.data.frame(regionJuncOve)
    # regionJuncOve.df <- cbind(regionJuncOve.df,junId=mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"juncId"])
    # regionJuncOve.df <- regionJuncOve.df[!regionJuncOve.df$queryHits%in%which(!is.na(tmp.intergenicRegions$junId)),]

    regionJuncOve.df.tmp <-
        regionJuncOve.df %>%
        mutate(queryhits_junId = str_c(junID, "_", queryHits))

    regionJuncOve.df <- regionJuncOve.df %>%
        inner_join(regionJuncOve.df.tmp, by = "junID") %>%
        arrange(junID) %>%
        mutate(to_keep = ifelse(duplicated(queryhits_junId, fromLast = T) | duplicated(queryhits_junId, fromLast = F),
                                ifelse(queryHits.x == queryHits.y, F, T), T)) %>%
        filter(to_keep == T) %>%
        mutate(queryHits_dup = ifelse(queryHits.x == queryHits.y, NA, queryHits.y)) %>%
        dplyr::select(queryHits = queryHits.x, subjectHits.x, junID, queryHits_dup)

    regionJuncOve.df <- regionJuncOve.df[!is.na(regionJuncOve.df$queryHits_dup),]


    ## add inforamtion about the junction

    ## add information about the relationship between two Expressed regions
    tmp.regions[regionJuncOve.df$queryHits,"junER"] <- regionJuncOve.df$queryHits_dup

    tmp.regions[regionJuncOve.df$queryHits,"annotationType"] <- 2

    # add the transcript information and distance this is remove for the moment, I want to speak with Mina first
    # tmp.intergenicRegions[regionJuncOve.df$queryHits,c(colnames( tmp.annotatedJunction)[c(1,6:10,12)],"pred_strand")] <- tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"juncId"],tmp.annotatedJunction$junId),c(colnames( tmp.annotatedJunction)[c(1,6:10,12)],"strand")]
    # regionJuncOve.df <- as.data.frame(regionJuncOve)
    # regionJuncOve.df <- cbind(regionJuncOve.df,tmp.annotatedJunction[match(mcols(juncti.GR[regionJuncOve.df$subjectHits])[,"juncId"],tmp.annotatedJunction$junId),c("acceptor","donor")])
    # regionJuncOve.df <- regionJuncOve.df[!regionJuncOve.df$queryHits%in%which(!is.na(tmp.intergenicRegions$junId)),]
    # setDT(regionJuncOve.df)
    # regionJuncOve.df <- regionJuncOve.df[ , .(transcipt = paste(unique(unlist(strsplit(as.character(c(acceptor,donor)),","))), collapse=",")), by = queryHits]
    # setDF(regionJuncOve.df)
    # tmp.intergenicRegions[regionJuncOve.df$queryHits,"transcript"] <- regionJuncOve.df$transcipt
    #
    # ## calculate the distance using the minimum of all the distances between start and stop of the regions
    # tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"distance"] <- apply(abs(cbind(tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"start"] -
    #                                                                                            tmp.intergenicRegions[tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"junER"],"end"],
    #                                                                                          tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"end"] -
    #                                                                                            tmp.intergenicRegions[tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"junER"],"start"],
    #                                                                                          tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"start"] -
    #                                                                                            tmp.intergenicRegions[tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"junER"],"end"],
    #                                                                                          tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"end"] -
    #                                                                                            tmp.intergenicRegions[tmp.intergenicRegions[!is.na(tmp.intergenicRegions$junER),"junER"],"start"])),1,min)

    rm(regionJuncOve)

    ## make the data frame consistent
    tmp.regions[tmp.regions==""] <- NA

    ########################################################################################
    ## step 3. annotate regions based on the nearest gene that have junction annotated  ####
    ########################################################################################

    # tmp.annotatedJunction <-  annotatedJunction[which(annotatedJunction$acceptor!="" | annotatedJunction$donor!="" |annotatedJunction$junction!=""),]
    #
    # ## +- 1 in the coordinates to match the exon boundaries
    # if(grepl("chr",as.character(annotatedJunction$chr[1])))
    # {
    #     juncti.GR <- GRanges(c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr)),
    #                          IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
    #                                  end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
    #                          juncId=c(tmp.annotatedJunction$junId,tmp.annotatedJunction$junId))
    #
    # }else{
    #     juncti.GR <- GRanges(paste0("chr",c(as.character(tmp.annotatedJunction$chr),as.character(tmp.annotatedJunction$chr))),
    #                          IRanges(start=c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1),
    #                                  end = c(tmp.annotatedJunction$start-1,tmp.annotatedJunction$stop+1)),
    #                          juncId=c(tmp.annotatedJunction$junId,tmp.annotatedJunction$junId))
    # }
    #
    # ## calculate the distance to nearest junction, junction which is annotated with a gene
    # distNearest <- as.data.frame(distanceToNearest(intergenicRegions,juncti.GR,ignore.strand=FALSE))
    # ## add the juncId
    # distNearest <- cbind(distNearest,junId=mcols(juncti.GR[distNearest$subjectHits])[,"juncId"])
    # ## add the distance for those records were we already have added the distance based on the overlapping junction
    #
    # distNearest <- distNearest[!distNearest$queryHits%in%which(!is.na(tmp.intergenicRegions$junId)),]
    # head(distNearest)
    # # queryHits subjectHits distance  junId
    # # 1         1      189013   177302 208302
    # # 2         2      189013   171464 208302
    # # 3         3      189013   151319 208302
    # # 4         4      189013   150463 208302
    # # 5         5      189013    66899 208302
    # # 6         6      189013    51905 208302
    #
    # distNearest <- cbind(distNearest,tmp.annotatedJunction[match(mcols(juncti.GR[distNearest$subjectHits])[,"juncId"],tmp.annotatedJunction$junId),c("strand","intronMotif","inAnnotation","countsSamples","acceptor","donor","precBound","junction")])
    #
    # tmp.intergenicRegions[distNearest$queryHits,c(colnames( tmp.annotatedJunction)[c(1,6:10,12)],"pred_strand","distance")] <-
    #     distNearest[,c("junId","intronMotif","inAnnotation","countsSamples","acceptor","donor","precBound","strand","distance")]
    #
    # ## first speak to Mina
    # ##tmp.intergenicRegions[distNearest$queryHits,"annotationType"] <- 3
    # ## otherwise leave this
    # tmp.intergenicRegions[distNearest[distNearest$queryHits%in%which(is.na(tmp.intergenicRegions$annotationType)) ,"queryHits"],"annotationType"] <- 3
    #
    #
    # table(tmp.intergenicRegions$annotationType)
    #
    # setDT(distNearest)
    # distNearest <- distNearest[ , .(transcipt = paste(unique(unlist(strsplit(as.character(c(acceptor,donor,junction)),","))), collapse=",")), by = queryHits]
    # setDF(distNearest)
    #
    # tmp.intergenicRegions[distNearest$queryHits,"transcript"] <- distNearest$transcipt

    message(paste(Sys.time(),"--",
                  paste0(round((table(is.na(tmp.regions$junID))["FALSE"]/nrow(tmp.regions))*100,digits = 2),"%"),"regions annotated with known genes"))

    message(paste(Sys.time(),"--",
                  paste0(round((table(tmp.regions$annotationType==2)["TRUE"]/nrow(tmp.regions))*100,digits = 2),"%"),"regions annotated linked together"))

    return(tmp.regions)
}


